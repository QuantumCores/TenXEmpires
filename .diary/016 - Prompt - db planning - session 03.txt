0. Should manual saves remain slot-based (1..3 with overwrite/delete) per PRD, or switch to a rolling “latest 3 manual saves” model? Recommendation: Keep slot-based manual saves to match UX; enforce UNIQUE (user_id, game_id, slot) with CHECK (slot between 1 and 3) and reserve the ring buffer for autosaves only.

1. Should manual saves remain slot-based (1..3 with overwrite/delete) per PRD, or switch to a rolling “latest 3 manual saves” model? Recommendation: Keep slot-based manual saves to match UX; enforce UNIQUE (user_id, game_id, slot) with CHECK (slot between 1 and 3) and reserve the ring buffer for autosaves only.
What storage type will we use for ULID user IDs in Postgres, and how will EF Core map it?
Recommendation: Prefer uuid (ideally time-ordered v7) for seamless EF/Npgsql support; if ULID is mandatory, store as char(26) with a CHECK pattern and ensure all user_id FKs use the same type.

2. Will ASP.NET Identity be configured to use the same key type (ULID/uuid) as users.id?
Recommendation: Configure Identity to use a matching key type (e.g., string ULID or Guid), and ensure generation occurs in the app so DB FKs and cascades align cleanly.

3. Should games, saves, and analytics_events use bigint identity primary keys for headroom?
Recommendation: Yes—use bigint generated always as identity for these tables to avoid rollover risk; keep user_id as the ULID/uuid type consistently across references.

4. How will the backend set the current user for RLS within Postgres?
Recommendation: Use a session GUC (e.g., SET app.user_id = '...') and a SECURITY DEFINER function app.current_user_id(); define RLS USING (user_id = app.current_user_id()) and an admin role with BYPASSRLS.

5. Should the autosave/manual-save limits be enforced via DB triggers or application logic?
Recommendation: Use an AFTER INSERT trigger to delete older rows and keep only the latest 5 autosaves (per user, game); for manual slot-based saves, use INSERT ... ON CONFLICT (user_id, game_id, slot) DO UPDATE.

6. For analytics, do we store a hashed user identifier or a FK to users?
Recommendation: Store a FK user_id for integrity and cascades; expose a view analytics_events_export that selects sha256(user_id || salt) for privacy in exports.

7. Can we enforce idempotency for autosaves and analytics batches to handle retries?
Recommendation: Add unique keys like (game_id, turn_no) for autosave rows and an event_batch_id with a unique (game_id, turn_no, event_batch_id) for analytics to prevent duplicates.

8. Can users have multiple simultaneous active games, or is only one active game allowed?
Recommendation: Allow multiple active games for flexibility; if only one is desired, add a partial unique index on (user_id) where status = 'active'.

9. Which indexes should we create initially to meet MVP performance?
Recommendation: Add indexes: games(user_id, started_at desc), saves(user_id, game_id, kind, created_at desc) with a partial index where kind='autosave', and analytics_events(user_id, occurred_at), analytics_events(game_id, turn_no); defer GIN on state until needed.